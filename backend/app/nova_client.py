"""
Amazon Nova client via AWS Bedrock.
Falls back to a realistic mock when USE_MOCK=true or AWS creds are unavailable.
"""
import os
import json
import re
import boto3
from botocore.exceptions import ClientError, NoCredentialsError

MODEL_ID = os.getenv("NOVA_MODEL_ID", "amazon.nova-pro-v1:0")
AWS_REGION = os.getenv("AWS_REGION", "us-east-1")
USE_MOCK = os.getenv("USE_MOCK", "true").lower() == "true"


def _bedrock_client():
    return boto3.client("bedrock-runtime", region_name=AWS_REGION)


def invoke_nova(system_prompt: str, user_message: str) -> str:
    """Call Amazon Nova Pro via Bedrock. Falls back to mock on error."""
    if USE_MOCK:
        return _mock_response(system_prompt, user_message)
    try:
        client = _bedrock_client()
        body = {
            "messages": [{"role": "user", "content": [{"text": user_message}]}],
            "system": [{"text": system_prompt}],
            "inferenceConfig": {
                "maxTokens": 2048,
                "temperature": 0.3,
            },
        }
        response = client.invoke_model(
            modelId=MODEL_ID,
            body=json.dumps(body),
            contentType="application/json",
            accept="application/json",
        )
        result = json.loads(response["body"].read())
        return result["output"]["message"]["content"][0]["text"]
    except (NoCredentialsError, ClientError, Exception) as e:
        print(f"[Nova] Falling back to mock â€” {e}")
        return _mock_response(system_prompt, user_message)


# ---------------------------------------------------------------------------
# Realistic mock responses keyed by agent role
# ---------------------------------------------------------------------------

def _mock_response(system_prompt: str, user_message: str) -> str:
    sp = system_prompt.lower()

    if "planner" in sp:
        return _mock_planner(user_message)
    elif "code" in sp or "terraform" in sp or "script" in sp:
        return _mock_coder(user_message)
    elif "review" in sp or "security" in sp:
        return _mock_reviewer(user_message)
    elif "explain" in sp:
        return _mock_explainer(user_message)
    return "I'm Nova DevOps Copilot â€” ready to help with your DevOps pipeline!"


def _mock_planner(request: str) -> str:
    req_lower = request.lower()
    if "ecs" in req_lower or "container" in req_lower:
        steps = [
            "1. Create an ECR repository to store your Docker image",
            "2. Build and push the Docker image to ECR",
            "3. Define an ECS Task Definition (Fargate launch type)",
            "4. Create an ECS Cluster and Service",
            "5. Configure an Application Load Balancer (ALB) for traffic routing",
            "6. Set up IAM roles for ECS task execution",
            "7. Configure CloudWatch logging for the ECS service",
            "8. Create a GitHub Actions CI/CD workflow to automate deployments",
        ]
    elif "lambda" in req_lower or "serverless" in req_lower:
        steps = [
            "1. Package your application code into a deployment ZIP",
            "2. Create an IAM execution role for the Lambda function",
            "3. Deploy the Lambda function with appropriate runtime settings",
            "4. Configure an API Gateway trigger (HTTP endpoint)",
            "5. Set up environment variables and secrets via SSM Parameter Store",
            "6. Enable CloudWatch Logs and X-Ray tracing",
            "7. Create a GitHub Actions workflow for automated Lambda deployments",
        ]
    elif "kubernetes" in req_lower or "k8s" in req_lower or "eks" in req_lower:
        steps = [
            "1. Provision an EKS cluster using Terraform",
            "2. Configure kubectl and aws-auth ConfigMap",
            "3. Deploy the application using Kubernetes Deployment manifests",
            "4. Expose the app via a Kubernetes Service + ALB Ingress Controller",
            "5. Configure Horizontal Pod Autoscaling (HPA)",
            "6. Set up Helm chart for repeatable deployments",
            "7. Implement GitHub Actions CI/CD with kubectl apply",
        ]
    else:
        steps = [
            "1. Analyze the application architecture and deployment requirements",
            "2. Provision the target infrastructure using Terraform",
            "3. Configure networking (VPC, subnets, security groups)",
            "4. Set up IAM roles and security policies",
            "5. Deploy the application to the target environment",
            "6. Configure monitoring and alerting (CloudWatch)",
            "7. Create a CI/CD pipeline with GitHub Actions",
            "8. Document the deployment process and runbook",
        ]
    return "## DevOps Pipeline Plan\n\n" + "\n".join(steps) + \
           "\n\n> âœ… Plan generated by Nova PlannerAgent"


def _mock_coder(context: str) -> str:
    ctx_lower = context.lower()
    if "ecs" in ctx_lower or "ecr" in ctx_lower:
        return '''## Generated Infrastructure Code

### terraform/main.tf
```hcl
terraform {
  required_providers {
    aws = { source = "hashicorp/aws", version = "~> 5.0" }
  }
}

provider "aws" {
  region = var.aws_region
}

# ECR Repository
resource "aws_ecr_repository" "app" {
  name                 = var.app_name
  image_tag_mutability = "MUTABLE"
  image_scanning_configuration {
    scan_on_push = true
  }
}

# ECS Cluster
resource "aws_ecs_cluster" "main" {
  name = "${var.app_name}-cluster"
  setting {
    name  = "containerInsights"
    value = "enabled"
  }
}

# ECS Task Definition
resource "aws_ecs_task_definition" "app" {
  family                   = var.app_name
  network_mode             = "awsvpc"
  requires_compatibilities = ["FARGATE"]
  cpu                      = "256"
  memory                   = "512"
  execution_role_arn       = aws_iam_role.ecs_execution.arn

  container_definitions = jsonencode([{
    name  = var.app_name
    image = "${aws_ecr_repository.app.repository_url}:latest"
    portMappings = [{ containerPort = 80, protocol = "tcp" }]
    logConfiguration = {
      logDriver = "awslogs"
      options = {
        "awslogs-group"         = "/ecs/${var.app_name}"
        "awslogs-region"        = var.aws_region
        "awslogs-stream-prefix" = "ecs"
      }
    }
  }])
}

# ECS Service
resource "aws_ecs_service" "app" {
  name            = "${var.app_name}-service"
  cluster         = aws_ecs_cluster.main.id
  task_definition = aws_ecs_task_definition.app.arn
  desired_count   = 2
  launch_type     = "FARGATE"

  network_configuration {
    subnets          = var.subnet_ids
    security_groups  = [aws_security_group.ecs.id]
    assign_public_ip = true
  }

  load_balancer {
    target_group_arn = aws_lb_target_group.app.arn
    container_name   = var.app_name
    container_port   = 80
  }
}
```

### .github/workflows/deploy.yml
```yaml
name: Deploy to ECS

on:
  push:
    branches: [main]

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
  ECS_SERVICE: ${{ secrets.ECS_SERVICE }}
  ECS_CLUSTER: ${{ secrets.ECS_CLUSTER }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push image to ECR
        run: |
          docker build -t $ECR_REPOSITORY:$GITHUB_SHA .
          docker push $ECR_REPOSITORY:$GITHUB_SHA

      - name: Deploy to ECS
        run: |
          aws ecs update-service \\
            --cluster $ECS_CLUSTER \\
            --service $ECS_SERVICE \\
            --force-new-deployment
```

> âœ… Code generated by Nova CodeAgent'''
    else:
        return '''## Generated Infrastructure Code

### terraform/main.tf
```hcl
terraform {
  required_providers {
    aws = { source = "hashicorp/aws", version = "~> 5.0" }
  }
}

provider "aws" {
  region = var.aws_region
}

# VPC
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "~> 5.0"
  name    = "${var.app_name}-vpc"
  cidr    = "10.0.0.0/16"
  azs             = ["${var.aws_region}a", "${var.aws_region}b"]
  private_subnets = ["10.0.1.0/24", "10.0.2.0/24"]
  public_subnets  = ["10.0.101.0/24", "10.0.102.0/24"]
  enable_nat_gateway = true
}

# Security Group
resource "aws_security_group" "app" {
  name   = "${var.app_name}-sg"
  vpc_id = module.vpc.vpc_id

  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}
```

### .github/workflows/ci-cd.yml
```yaml
name: CI/CD Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run tests
        run: |
          npm ci
          npm test

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == \'refs/heads/main\'
    steps:
      - uses: actions/checkout@v4
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      - name: Deploy infrastructure
        run: |
          cd terraform
          terraform init
          terraform apply -auto-approve
```

> âœ… Code generated by Nova CodeAgent'''


def _mock_reviewer(code: str) -> str:
    return '''## Security & Best Practices Review

### âœ… Passed Checks
- IAM roles follow least-privilege principle
- No hardcoded credentials detected in code
- Security groups restrict ingress to required ports only
- Docker image scanning enabled on ECR push
- CloudWatch logging configured for audit trail

### âš ï¸ Recommendations
1. **State Backend** â€” Store Terraform state in S3 with DynamoDB locking:
   ```hcl
   terraform {
     backend "s3" {
       bucket         = "your-tfstate-bucket"
       key            = "prod/terraform.tfstate"
       region         = "us-east-1"
       dynamodb_table = "terraform-locks"
       encrypt        = true
     }
   }
   ```
2. **Secrets Management** â€” Use AWS Secrets Manager or SSM Parameter Store instead of GitHub Secrets for sensitive values
3. **Image Tags** â€” Pin Docker image tags to specific SHAs instead of `latest` in production
4. **VPC Endpoints** â€” Add VPC endpoints for ECR/S3 to avoid data leaving the VPC
5. **Container Read-Only FS** â€” Set `readonlyRootFilesystem: true` in task definition

### ðŸ”’ Security Score: 8/10

> âœ… Review completed by Nova ReviewAgent'''


def _mock_explainer(context: str) -> str:
    return '''## Plain-English Explanation

### What This Pipeline Does

**Step 1 â€” Plan:** The PlannerAgent analyzed your request and broke it into 7-8 concrete steps, ordering them by dependency (infrastructure before app deployment, networking before compute).

**Step 2 â€” Code:** The CodeAgent generated:
- **Terraform IaC** to provision your AWS infrastructure declaratively â€” meaning you can version-control your infra and reproduce it exactly
- **GitHub Actions workflow** that automatically builds your Docker image, pushes it to ECR (Amazon's container registry), and triggers a rolling deployment every time you push to `main`

**Step 3 â€” Review:** The ReviewAgent checked the generated code for:
- Security vulnerabilities (hardcoded secrets, over-permissive IAM, open security groups)
- AWS best practices (state management, logging, tagging)
- Operational concerns (health checks, auto-scaling, rollback strategy)

### The Big Picture

Every time a developer pushes code to GitHub:
1. ðŸ§ª Tests run automatically
2. ðŸ³ A Docker image is built and tagged with the commit SHA
3. ðŸ“¦ The image is pushed to your private ECR registry
4. ðŸš€ ECS pulls the new image and performs a zero-downtime rolling update
5. ðŸ“Š CloudWatch monitors the deployment and alerts on errors

**No manual steps. No SSH into servers. No "it works on my machine."**

> âœ… Explanation by Nova ExplainerAgent'''
